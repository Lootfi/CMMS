package project;
import java.util.Scanner;

public class SysExploitation {
		
	Scanner scan = new Scanner(System.in);
	private FiledAttente FileInitial = new FiledAttente();
//	private AllocStatique AllocStat = null;
//	private AllocDynamique AllocDyn = null;
	private MemoirePrincipale MemPrincipale;
	public String typeAlloc;
	  /* MemoireSecondaire MemSecondaire = new MemoireSecondaire(); */
	Processeur Processeur = new Processeur();
	Ordonnanceur Ordo = new Ordonnanceur();
	int time = 0;

	public void initSimulation() {
		
		int restart = 0;
		FiledAttente clonedFileInitial = null;
		System.out.println("This is a Computer Memory Allocation and Overall Behavior simulation\nEnjoy ...");
		do {
		this.initMP();
		if(clonedFileInitial.isEmpty()) {
			this.initMultipProcessus();			
			clonedFileInitial = this.getFileInitial().clone();
		}
		/*Start of methods that excecute every time unit*/
		
		//there must be a method here that frees the processor,memory
		this.FileInitialtoFileMemoire(); //this method is supposed to run every time unit
		this.getMemPrincipale().allouer(); // every time unit too
		
		/*End of methods that excecute every unit*/
		
		
		/* End of Simulation Process */
		do {
		System.out.println("Do you want to restart the simulation?");
		System.out.println("1- Yes");
		System.out.println("2- No");
		restart = scan.nextInt();
		}while(restart != 2 || restart != 1);
		if(restart == 2) break;
		else {
			int useSameProc = 0;
			do {
			System.out.println("Do you want to use the same processus as the previous simulation?");
			System.out.println("1- Yes");
			System.out.println("2- No");
			useSameProc = scan.nextInt();
				}while(useSameProc != 1 || useSameProc != 2);
			if(useSameProc == 2) clonedFileInitial = null;
		}
		}while(restart == 1);
	}
	
	
	/* initializing a RAM
	 *
	 *	Asks for memory type first.
	 *	Takes user input and initializes a memory accordingly
	 *	...
	 */	
	public void initMP() {
		
		int typeMem = 0;
		
		do {
		System.out.println("Initialisation d'une Mémoire Principale ...");
		System.out.println("Donner le type d'allocation Mémoire: ");
		System.out.println("I - Allocation statique contigue: ");
		System.out.println("\t 1- Allocation d'une zone en statique");
		System.out.println("\t 2- Allocation de N zones en statique avec une seule file");
		System.out.println("\t 3- Allocation de N zones en statique avec N files");
		typeMem = scan.nextInt();
				} while(typeMem < 1 || typeMem > 3);
		
		switch(typeMem) {
		
		case 1: {
			int TailleZone;
			ZoneRAM[] Zones = new ZoneRAM[1];
			
			do {
			System.out.println("Donnez la taille de la zone/mémoire: ");
			TailleZone = scan.nextInt(); } while(TailleZone < 1);
			
			Zones[0] = new ZoneRAM(TailleZone);

			FiledAttente F = new FiledAttente();
			
			MemPrincipale = new AllocUneZoneStatique(Zones,TailleZone,F);
			MemPrincipale.setTailleMemoire(TailleZone);
			typeAlloc = "AllocUneZoneStatique";
			break;
		}
		
		case 2: {
			int TailleZone,TailleMemoire;
			do {
				System.out.println("Donnez la taille de la mémoire principale");
				TailleMemoire = scan.nextInt();
			}while(TailleMemoire < 1);
			do {
				System.out.println("Donnez la taille de la zone: ");
				TailleZone = scan.nextInt();
			} while(TailleZone < 1 && TailleZone >= TailleMemoire);
			
			ZoneRAM[] Zones = new ZoneRAM[TailleMemoire / TailleZone];
			
			for(int i = 0; i <Zones.length; i++) {
				Zones[i] = new ZoneRAM(TailleZone);
			}
			
			FiledAttente F = new FiledAttente();
		
			
			MemPrincipale = new AllocNZonesUneFile(Zones,TailleMemoire,F);
			
			typeAlloc = "AllocNZonesUneFile";
			
			break;
		}
		
		case 3: {
			int TailleZone,TailleMemoire;
			do {
				System.out.println("Donnez la taille de la mémoire principale");
				TailleMemoire = scan.nextInt();
			}while(TailleMemoire < 1);
			do {
				System.out.println("Donnez la taille de la zone: ");
				TailleZone = scan.nextInt();
			} while(TailleZone < 1 && TailleZone >= TailleMemoire);
			
			ZoneRAM[] Zones = new ZoneRAM[TailleMemoire / TailleZone];
			
			for(int i = 0; i <Zones.length; i++) {
				FiledAttente F = new FiledAttente();
				Zones[i] = new ZoneRAM(TailleZone,F);
			}
			
			MemPrincipale = new AllocNZonesNFiles(Zones,TailleMemoire);

			typeAlloc = "AllocNZonesNFiles";
			
			break;
		}
		
		default:{
			break;
		}
		
		}
	}
	
	public void initMultipProcessus() {
		int init;
		do {
			System.out.println("Initialisation des processus .. ");
			System.out.println("1- Initialiser un nouveau Processus");
			System.out.println("2- Quit");
			init = scan.nextInt();
			if(init == 1) {
				this.initProcessus();
			}			
		} while(init != 2);
	}
	
	public void initProcessus() {
		
		int tempsA,tempsE,tailleA;
		
		System.out.println("Initialisation d'un processus ...");
		do {
		System.out.println("Le temps d'arrivé: ");
		if(this.getFileInitial().tetedeFile() != null) {
			System.out.println("Min: "+ this.getFileInitial().getLastProcTA());	
		}
		System.out.println(this.getFileInitial().toString());
		tempsA = scan.nextInt();} while(tempsA < 0 || this.getFileInitial().getLastProcTA() > tempsA);
		
		do {
		System.out.println("Le temps d'éxécution: ");
		 tempsE = scan.nextInt();} while(tempsE <= 0);
		
		do {
		System.out.println("La taille d'allocation: ");
		 tailleA = scan.nextInt();} while(tailleA <= 0);
		
		Processus P = new Processus(tempsA,tempsE,tailleA);
		
		if(this.getMemPrincipale().getClass().getSimpleName().equals("AllocNZonesNFiles")) {
			
			int indexFile;
		
			do {
			System.out.println("L'index de File d'Attente: ");
			indexFile = scan.nextInt();} while(indexFile<0 || (indexFile > this.getMemPrincipale().getNumZonesPages() - 1));
		
			P.setIdFile(indexFile);
			
		}
		
//		System.out.println(P);
		
		this.getFileInitial().enfiler(P);
	}

	
	public void FileInitialtoFileMemoire() {
		if(this.typeAlloc == "AllocNZonesUneFile" || this.typeAlloc == "AllocUneZoneStatique") {
			while(!this.getFileInitial().isEmpty()) {
				int tempsArrivP = this.getFileInitial().tetedeFile().getTempsAriv();
				if(tempsArrivP == this.time) {
					this.getMemPrincipale().getFilo().enfiler(this.getFileInitial().defiler());
				}
				else break;
			}			
		}
		else if(this.typeAlloc == "AllocNZonesNFiles"){
			while(!this.getFileInitial().isEmpty()) {
				int tempsArrivP = this.getFileInitial().tetedeFile().getTempsAriv();
				if(tempsArrivP == this.time) {
					Processus P = this.getFileInitial().defiler();
					for (ZoneRAM zone : this.getMemPrincipale().getZones()) {
						if(P.getIdFile() == zone.getFiledeZone().id) {
							zone.getFiledeZone().enfiler(P);
							break;
						}
					}
				}
				else break;
			}
		}
	}

	public MemoirePrincipale getMemPrincipale() {
		return MemPrincipale;
	}


	public void setMemPrincipale(MemoirePrincipale memPrincipale) {
		MemPrincipale = memPrincipale;
	}


	public FiledAttente getFileInitial() {
		return FileInitial;
	}


	public void setFileInitial(FiledAttente fileInitial) {
		FileInitial = fileInitial;
	}

}
